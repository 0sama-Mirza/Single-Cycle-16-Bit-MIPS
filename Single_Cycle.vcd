$date
	Mon Jun 12 00:49:24 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module Single_Cycle_Top_tb $end
$var reg 1 ! clk $end
$var reg 1 " rst $end
$scope module Single_Cycle_Top $end
$var wire 2 # ALUOp_Out [1:0] $end
$var wire 1 $ ALUSrc_Out $end
$var wire 1 % MemRead_Out $end
$var wire 1 & MemToReg_Out $end
$var wire 1 ' MemWrite_Out $end
$var wire 1 ( RegDst_Out $end
$var wire 1 ) Reg_Write_Out $end
$var wire 1 ! clk $end
$var wire 1 * clk_out $end
$var wire 1 " rst $end
$var wire 1 + rst_out $end
$var wire 3 , random [2:0] $end
$var wire 16 - SignExt_Top [15:0] $end
$var wire 1 . RegWrite $end
$var wire 1 / RegDst $end
$var wire 16 0 ReadData [15:0] $end
$var wire 16 1 RD_Instr [15:0] $end
$var wire 16 2 RD2_Top [15:0] $end
$var wire 16 3 RD1_Top [15:0] $end
$var wire 16 4 PC_Top [15:0] $end
$var wire 16 5 NEW_PC [15:0] $end
$var wire 16 6 Mux_Register_To_ALU_Result [15:0] $end
$var wire 16 7 Mux_Data_Memory_To_Register_File_Write_Back_Result [15:0] $end
$var wire 1 8 MemWrite $end
$var wire 1 9 MemToReg $end
$var wire 1 : MemRead $end
$var wire 16 ; ALU_RESULT [15:0] $end
$var wire 1 < ALUSrc $end
$var wire 2 = ALUOp [1:0] $end
$var wire 3 > ALUControl_Top [2:0] $end
$scope module ALU $end
$var wire 1 ? Carry $end
$var wire 16 @ Result [15:0] $end
$var wire 16 A a_and_b [15:0] $end
$var wire 16 B a_or_b [15:0] $end
$var wire 16 C not_b [15:0] $end
$var wire 16 D sum [15:0] $end
$var wire 16 E mux_2 [15:0] $end
$var wire 16 F mux_1 [15:0] $end
$var wire 1 G cout $end
$var wire 1 H Zero $end
$var wire 1 I Negative $end
$var wire 16 J B [15:0] $end
$var wire 3 K ALUControl [2:0] $end
$var wire 16 L A [15:0] $end
$upscope $end
$scope module ALU_Control $end
$var wire 4 M Fun [3:0] $end
$var wire 2 N alu_op [1:0] $end
$var wire 6 O ALUControlIn [5:0] $end
$var wire 3 P ALUControl [2:0] $end
$upscope $end
$scope module Control_Unit $end
$var wire 3 Q op [2:0] $end
$var wire 1 . RegWrite $end
$var wire 1 / RegDst $end
$var wire 1 8 MemWrite $end
$var wire 1 9 MemToReg $end
$var wire 1 : MemRead $end
$var wire 1 < ALUSrc $end
$var wire 2 R ALUOp [1:0] $end
$upscope $end
$scope module Data_Memory $end
$var wire 16 S A [15:0] $end
$var wire 1 : RE $end
$var wire 1 8 WE $end
$var wire 1 ! clk $end
$var wire 16 T WD [15:0] $end
$var wire 16 U RD [15:0] $end
$upscope $end
$scope module Instruction_Memory $end
$var wire 1 " rst $end
$var wire 16 V RD [15:0] $end
$var wire 16 W A [15:0] $end
$upscope $end
$scope module Mux_Data_Memory_To_Register_File_Write_Back $end
$var wire 16 X In1 [15:0] $end
$var wire 16 Y In2 [15:0] $end
$var wire 1 9 Selection $end
$var wire 16 Z Out [15:0] $end
$upscope $end
$scope module Mux_Register_To_ALU $end
$var wire 1 < Selection $end
$var wire 16 [ Out [15:0] $end
$var wire 16 \ In2 [15:0] $end
$var wire 16 ] In1 [15:0] $end
$upscope $end
$scope module PC $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var wire 16 ^ PC_NEXT [15:0] $end
$var reg 16 _ pc [15:0] $end
$upscope $end
$scope module PC_Adder $end
$var wire 16 ` Four16Bit [15:0] $end
$var wire 16 a OLD_PC [15:0] $end
$var wire 16 b NEW_PC [15:0] $end
$upscope $end
$scope module Register_File $end
$var wire 3 c A1 [2:0] $end
$var wire 3 d A2 [2:0] $end
$var wire 3 e A3 [2:0] $end
$var wire 16 f WD3 [15:0] $end
$var wire 1 . WE3 $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var wire 16 g RD2 [15:0] $end
$var wire 16 h RD1 [15:0] $end
$upscope $end
$scope module Sign_Extend $end
$var wire 16 i In_Str [15:0] $end
$var wire 16 j Extended_Out [15:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
b0 j
b0 i
b0 h
b0 g
b0 f
b0 e
b0 d
b0 c
bx b
bx a
b100 `
bx _
bx ^
b0 ]
b0 \
b0 [
b0 Z
b0 Y
b0 X
bx W
b0 V
b0 U
b0 T
b0 S
b0 R
b0 Q
b0 P
b0 O
b0 N
b0 M
b0 L
b0 K
b0 J
0I
1H
0G
b0 F
b0 E
b0 D
b1111111111111111 C
b0 B
b0 A
b0 @
0?
b0 >
b0 =
0<
b0 ;
0:
09
08
b0 7
b0 6
bx 5
bx 4
b0 3
b0 2
b0 1
b0 0
1/
1.
b0 -
b0 ,
0+
0*
z)
1(
0'
0&
0%
0$
b0 #
0"
0!
$end
#100
b100 5
b100 ^
b100 b
b0 4
b0 W
b0 _
b0 a
1*
1!
#150
0H
b11 7
b11 Z
b11 f
b1 F
b1111111111111110 C
bx 0
bx U
bx Y
b11 ;
b11 @
b11 S
b11 X
b11 E
b1 6
b1 J
b1 [
b11 D
b11 B
b1111111110000011 -
b1111111110000011 \
b1111111110000011 j
b1 2
b1 T
b1 ]
b1 g
b10 3
b10 L
b10 h
b11 e
b10 d
b1 c
b10 ,
b11010001000 1
b11010001000 V
b11010001000 i
1+
1"
#200
0*
0!
#300
b1 7
b1 Z
b1 f
1?
b1 ;
b1 @
b1 S
b1 X
b1 E
1G
b1 D
b1111111111111110 F
b1 >
b1 K
b1 P
b1111111110001011 -
b1111111110001011 \
b1111111110001011 j
b1 O
b1 M
b1011010001000 1
b1011010001000 V
b1011010001000 i
b1000 5
b1000 ^
b1000 b
b100 4
b100 W
b100 _
b100 a
1*
1!
#400
0*
0!
#500
1H
b0 7
b0 Z
b0 f
0?
b0 ;
b0 @
b0 S
b0 X
b0 E
0G
b11 D
b1 F
b10 >
b10 K
b10 P
b1111111110010011 -
b1111111110010011 \
b1111111110010011 j
b10 O
b10 M
b10011010001000 1
b10011010001000 V
b10011010001000 i
b1100 5
b1100 ^
b1100 b
b1000 4
b1000 W
b1000 _
b1000 a
1*
1!
#600
0*
0!
